import jsonimport urllibimport codecsimport requestsDATA_URL = 'http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz'CONFIG_URL = 'http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/wczytaj-konfiguracje'HEADERS = {    'Accept': 'application/json, text/javascript, */*; q=0.01',    'Accept-Encoding': 'gzip, deflate',    'Accept-Language': 'pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4',    'Connection': 'keep-alive',    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',    'Host': 'monitoring.krakow.pios.gov.pl',    'Origin': 'http://monitoring.krakow.pios.gov.pl',    'Referer': 'http://monitoring.krakow.pios.gov.pl',    'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36',    'X-Requested-With': 'XMLHttpRequest'}stations = {    4: 'Tarnow',    5: 'Skawina',    6: 'Aleja Krasinskiego',    7: 'Nowa Huta',    8: 'Nowy Sacz',    9: 'Zakopane',    10: 'Olkusz',    11: 'Trzebinia',    12: 'Szymbark',    15: 'Szarow',    16: 'Krakow-Kurdwanow',    19: 'Limanowa P',    20: 'Szczawnica P',    21: 'Kety P',    23: 'Slomniki P',    24: 'Myslenice P',    25: 'Bukowno P',    29: 'Sucha Beskidzka II',    148: 'Szarow Spokojna'}channels = {'pl_PL': {        47: 'Tlenki Azotu',        49: 'Benzen',        50: 'Tlenek Wegla',        53: 'Tlenek Azotu',        54: 'Dwutlenek Azotu',        57: 'PM10',        61: 'Dwutlenek Siarki',        146: 'Ozon',        211: 'PM25'},    'en_US': {        47: 'Nitrogen Monoxides',        49: 'Benzene',        50: 'Carbon Monoxide',        53: 'Nitrogen Monoxide',        54: 'Nitrogen Dioxide',        57: 'PM10',        61: 'Sulfur Dioxide',        146: 'Ozone',        211: 'PM25'    }}class MeasPeriod:    DAY = 'day'    MONTH = 'month'    YEAR = 'year'class ViewType:    STATION = 'station'    PARAM = 'parameter'skip = ('avg', 'data', 'thresholds', 'thresholdsForAvg')labels = (    'timestamp', 'value', 'aggType', 'chartTooltipContent', 'count', 'coverageRate', 'decimals', 'extStartTime',    'interval',    'isAvgValid', 'label', 'ord', 'paramCode', 'paramId', 'paramLabel', 'paramPostfix', 'retroCount',    'scaleMax', 'scaleMin', 'startTime', 'unit', 'unitLabel')def flatten(data, separator='.', prefix=''):    """    Flattens multilevel dicts into single level dicts combining keys for subsequent levels using specified separator.    If dictionary contains element with empty dictionary as a value, it will be removed from the result    Args:        data: dictionary to flatten        separator: used when creating flattened key identifiers        prefix: optional prefix for all key identifiers    Returns:        flattened dict if 'data' parameter was dict or empty dict otherwise    """    storage = {}    if isinstance(data, dict):        for key, value in data.items():            new_prefix = key if prefix == '' else prefix + separator + key            if isinstance(value, dict):                storage.update(flatten(value, separator=separator, prefix=new_prefix))            else:                storage[new_prefix] = value    return storageclass ResponseError(Exception):    """    Thrown when problems with server response occur.    """    passdef xml_http_request(url, headers, data):    """    Sends XMLHttpRequest to given address with header and data    Args:        url: to send request to        headers: JSON formatted header, HTTP encoded        data: JSON formatted data, HTTP encoded    Returns:        dict of JSON response from page    Raises:        ResponseError if couldn't retrieve valid data    """    raw_result = requests.post(url=url, headers=headers, data=data)    if raw_result.status_code != 200:        raise ResponseError('Server returned error {}: {}'.format(raw_result.status_code, raw_result.text))    result = json.loads(raw_result.content)    if not result['success']:        raise ResponseError('Server returned error \'{}\''.format(result['error']))    return resultclass Config:    def __init__(self, url):        self.config = None        self.url = url        self.update()    def update(self):        """        Sends request to WIOS server and updates instance with new data (they are originally        used to configure web page)        Returns:            dict with retrieved raw config        Raises:            ResponseError if couldn't retrieve valid data        """        try:            self.config = xml_http_request(CONFIG_URL, headers=HEADERS, data={'measType': 'auto'})['config']            return self.config        except KeyError as e:            raise ResponseError('\'config\' key not found in server response')    def get_raw_config(self):        """        Returns internally stored (with update() method) config from WIOS server        Returns:            dict with raw config        """        return self.config    def get_raw_channels(self):        """        Returns raw channels data returned from server.        Channel is the parameter (e.g. NO2) measured on specific station        :return: list of dicts        """        try:            return self.config['channels']        except KeyError:            raise ResponseError('\'channels\' key not found in server response')    def get_raw_stations(self):        """        Returns raw measuring stations data returned from server        :return: list of dicts that contain 'id' and 'name' fields        """        try:            return self.config['stations']        except KeyError:            raise ResponseError('\'stations\' key not found in server response')    def get_raw_params(self):        """        Returns raw pollution parameter (e.g. NO2) data returned from server        :return: list of dicts        """        try:            return self.config['params']        except KeyError:            raise ResponseError('\'params\' key not found in server response')    def get_raw_thresholds(self):        """        Returns thresholds for pollution parameters (e.g. NO2) data returned from server        :return: list of dicts        """        try:            return self.config['thresholds']        except KeyError:            raise ResponseError('\'thresholds\' key not found in server response')    def get_stations(self):        """        Reformats measuring station into dict.        Returns:            dict of station number as a key and station name (location) as a value        """        stations = {}        for entry in self.get_raw_stations():            stations[entry['id']] = entry['name']        return stationsdef get_raw_data(encoded_query):    """    Sends request to WIOS server and retrieves data    Args:        encoded_query: of query parameters    Returns:        dict of JSON response from page    Raises:        ResponseError if couldn't retrieve valid data    """    raw_result = xml_http_request(DATA_URL, headers=HEADERS, data=encoded_query)    return raw_resultdef prepare_query(station, channels, year, month=None, day=None,                  meas_type='Auto', view_type=ViewType.STATION, meas_period=MeasPeriod.DAY):    """    Prepares encoded JSON query to retrieve data    Args:        station: integer        channels: list of integers representing pollution types        year: integer year        month: integer month        day: integer day        meas_type: type of measurement TODO: check other types of measurement        view_type: whether server has to return data by pollution parameter for all of the stations or for one station            with all parameters. Available defines are in class ViewType        meas_period: can be one of defined in class MeasPeriod and defines period of measurements which can be daily,            monthly and yearly    Returns:        string of encoded JSON query    """    if meas_period == MeasPeriod.YEAR:        date = str(year)    elif meas_period == MeasPeriod.MONTH and month is not None:        date = str(month) + '.' + str(year)    elif month is not None and day is not None:        date = "{}.{}.{}".format(day, month, year)    else:        raise ValueError('Not enough parameters to create date for period of type \'{}\''.format(meas_period))    header = {        "measType": meas_type,        "viewType": view_type,        "dateRange": meas_period,        "date": date,        "viewTypeEntityId": station,        "channels": channels    }    return "query=" + urllib.quote(json.dumps(header, separators=(",", ":")))if __name__ == '__main__':    from pprint import pprint    #from samples import SAMPLE_RESPONSE    # storage = flatten(SAMPLE_RESPONSE['data'])    # pprint(storage)    # if SAMPLE_RESPONSE['success']:    #    print "\n".join([str(x) for x in flatten(SAMPLE_RESPONSE['data'])])    # else:    #    print "Data retrieval failed"    #prepared_query = prepare_query(station=5, channels=[31, 36, 34, 30, 32],    #                               year=2015, month=5, day=17, meas_period=MeasPeriod.MONTH)    #pprint(prepared_query)    #result = get_raw_data(prepared_query)    config = Config(CONFIG_URL)    pprint(config.get_stations())